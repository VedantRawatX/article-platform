    // File: src/chat/chat.gateway.ts (Backend)
    import {
      WebSocketGateway,
      SubscribeMessage,
      MessageBody,
      WebSocketServer,
      ConnectedSocket,
      OnGatewayConnection,
      OnGatewayDisconnect,
      OnGatewayInit,
      WsException, // For throwing WebSocket specific errors
    } from '@nestjs/websockets';
    import { Server, Socket } from 'socket.io';
    import { Logger, UseGuards, Injectable } from '@nestjs/common'; // Added UseGuards, Injectable
    import { JwtService } from '@nestjs/jwt'; // For verifying token
    import { UsersService } from '../users/users.service'; // To fetch user details
    // You might want a specific DTO for chat messages from client
    // interface ClientChatMessageDto { message: string; room?: string; }

    // Define the structure of a chat message that will be broadcasted
    interface ChatMessageBroadcast {
      id?: string; // Optional unique message ID generated by server
      senderId: string;
      senderName: string;
      message: string;
      timestamp: Date;
      room?: string;
    }

    // Interface for user data attached to socket
    interface AuthenticatedSocket extends Socket {
        data: {
            user: {
                id: string;
                email: string;
                firstName?: string;
                lastName?: string;
                role: string;
            };
        };
    }


    @WebSocketGateway({
      cors: {
        origin: process.env.FRONTEND_URL || '*',
        methods: ['GET', 'POST'],
        credentials: true,
      },
      // namespace: 'chat', // Optional namespace
    })
    export class ChatGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
      @WebSocketServer()
      server: Server;

      private logger: Logger = new Logger('ChatGateway');

      constructor(
        private readonly jwtService: JwtService,
        private readonly usersService: UsersService, // Inject UsersService
      ) {}

      afterInit(server: Server) {
        this.logger.log('ChatGateway Initialized!');
      }

      async handleConnection(client: AuthenticatedSocket, ...args: any[]) {
        const token = client.handshake.auth.token; // Token sent from client
        this.logger.log(`Client attempting to connect: ${client.id} with token: ${token ? 'present' : 'missing'}`);

        if (!token) {
          this.logger.warn(`Connection attempt from ${client.id} without token. Disconnecting.`);
          client.emit('authError', { message: 'Authentication token not provided.' });
          client.disconnect(true);
          return;
        }

        try {
          const payload = this.jwtService.verify(token, { secret: process.env.JWT_SECRET }); // Verify token
          // Fetch full user details to get names, etc.
          const user = await this.usersService.findById(payload.sub); // payload.sub should be user ID
          if (!user) {
            this.logger.warn(`User not found for token sub: ${payload.sub}. Disconnecting client ${client.id}.`);
            client.emit('authError', { message: 'Invalid user.' });
            client.disconnect(true);
            return;
          }

          // Attach user data to the socket instance for later use
          client.data.user = {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
          };

          this.logger.log(`Client connected & authenticated: ${client.id}, UserID: ${user.id}, Name: ${user.firstName || user.email}`);
          client.emit('connectionStatus', { status: 'connected', clientId: client.id, user: client.data.user });

          // Example: Auto-join a general room
          // client.join('general-chat');
          // this.server.to('general-chat').emit('userJoined', { userId: user.id, name: user.firstName || user.email });

        } catch (error) {
          this.logger.error(`Authentication failed for client ${client.id}: ${error.message}`);
          client.emit('authError', { message: 'Authentication failed: Invalid token.' });
          client.disconnect(true); // Disconnect if token is invalid
        }
      }

      handleDisconnect(client: AuthenticatedSocket) {
        this.logger.log(`Client disconnected: ${client.id}, UserID: ${client.data.user?.id}`);
        if (client.data.user) {
          // Example: Notify rooms the user was in
          // client.rooms.forEach(room => {
          //   if (room !== client.id) { // Don't emit to the client's own default room
          //     this.server.to(room).emit('userLeft', { userId: client.data.user.id, name: client.data.user.firstName || client.data.user.email, room });
          //   }
          // });
        }
      }

      @SubscribeMessage('sendMessage')
      handleMessage(
        @MessageBody() data: { message: string; room?: string }, // Client sends message and optional room
        @ConnectedSocket() client: AuthenticatedSocket,
      ): void {
        if (!client.data.user) {
          this.logger.warn(`Message from unauthenticated client ${client.id}. Ignoring.`);
          client.emit('authError', { message: 'Not authenticated. Please reconnect.' });
          return; // Or throw WsException
        }

        const { id: senderId, firstName, email } = client.data.user;
        const senderName = firstName || email.split('@')[0]; // Use firstName or derive from email

        const fullMessage: ChatMessageBroadcast = {
          senderId,
          senderName,
          message: data.message,
          timestamp: new Date(),
          room: data.room,
        };

        this.logger.log(`Message from ${senderName} (${senderId}): "${fullMessage.message}" to room: ${fullMessage.room || 'broadcast'}`);

        if (fullMessage.room) {
          this.server.to(fullMessage.room).emit('newMessage', fullMessage);
        } else {
          // Broadcast to all connected authenticated clients (or a default room if implemented)
          this.server.emit('newMessage', fullMessage);
        }
      }

      @SubscribeMessage('joinRoom')
      handleJoinRoom(
        @MessageBody() roomName: string,
        @ConnectedSocket() client: AuthenticatedSocket,
      ): void {
        if (!client.data.user) {
          client.emit('authError', { message: 'Authentication required to join rooms.' });
          return;
        }
        client.join(roomName);
        this.logger.log(`Client ${client.id} (User: ${client.data.user.id}) joined room: ${roomName}`);
        client.emit('joinedRoomAck', { room: roomName, status: 'joined' });
        // Notify others in the room
        // client.to(roomName).emit('userJoinedRoom', { userId: client.data.user.id, name: client.data.user.firstName || client.data.user.email, room: roomName });
      }

      @SubscribeMessage('leaveRoom')
      handleLeaveRoom(
        @MessageBody() roomName: string,
        @ConnectedSocket() client: AuthenticatedSocket,
      ): void {
         if (!client.data.user) return;
        client.leave(roomName);
        this.logger.log(`Client ${client.id} (User: ${client.data.user.id}) left room: ${roomName}`);
        client.emit('leftRoomAck', { room: roomName, status: 'left' });
      }
    }
    